# CUJ-059: Workflow Performance Optimization

## User Goal
Optimize workflow execution performance through parallel agent execution, checkpoint optimization, and resource management.

## Trigger
- "Optimize workflow performance"
- "Speed up workflow execution"
- "Parallel agent execution"
- "Reduce workflow latency"

## Workflow

**Execution Mode**: `performance-flow.yaml`

### Step 0: Planning Phase
- **Agent**: Planner
- **Input**: Workflow performance requirements
- **Output**: Optimization plan (`plan-{id}.json`)

### Step 0.1: Plan Rating Gate
- **Agent**: Orchestrator
- **Skill**: response-rater
- **Minimum Score**: 7/10

### Step 1: Performance Baseline
- **Agent**: Performance-Engineer
- **Actions**:
  - Measure current workflow execution time
  - Identify bottlenecks
  - Analyze agent dependencies
  - Profile resource usage
- **Output**: Baseline metrics (`performance-baseline-{id}.json`)

### Step 2: Parallel Execution Analysis
- **Agent**: Architect
- **Actions**:
  - Identify independent workflow steps
  - Map parallel execution opportunities
  - Design agent coordination strategy
  - Define synchronization points
- **Output**: Parallelization plan (`parallel-execution-plan-{id}.json`)

### Step 3: Checkpoint Optimization
- **Agent**: DevOps
- **Actions**:
  - Optimize checkpoint frequency
  - Reduce checkpoint file size
  - Implement incremental checkpoints
  - Configure checkpoint compression
- **Output**: Checkpoint strategy (`checkpoint-config-{id}.json`)

### Step 4: Resource Management
- **Agent**: Performance-Engineer
- **Actions**:
  - Implement agent pooling
  - Configure resource limits
  - Optimize context loading
  - Implement lazy artifact loading
- **Output**: Resource configuration (`resource-config-{id}.json`)

### Step 5: Implementation
- **Agent**: Developer
- **Actions**:
  - Implement parallel execution
  - Apply checkpoint optimizations
  - Integrate resource management
  - Add performance monitoring
- **Output**: Optimized workflow code

### Step 6: Performance Validation
- **Agent**: QA
- **Actions**:
  - Execute performance tests
  - Compare against baseline
  - Validate parallel correctness
  - Verify checkpoint integrity
- **Output**: Performance report (`performance-results-{id}.json`)

### Step 7: Final Review
- **Agent**: Code-Reviewer
- **Actions**:
  - Review optimization implementation
  - Validate performance gains
  - Check for race conditions
  - Verify resource cleanup

## Agents Used
- Planner (optimization strategy)
- Performance-Engineer (baseline, optimization, validation)
- Architect (parallelization design)
- DevOps (checkpoint optimization)
- Developer (implementation)
- QA (performance testing)
- Code-Reviewer (review)

## Skills Used
- `plan-generator` - Optimization planning
- `response-rater` - Plan validation
- `dependency-analyzer` - Identify independent steps
- `diagram-generator` - Visualize parallel execution
- `recovery` - Checkpoint optimization

## Expected Outputs
- Baseline metrics: `.claude/context/artifacts/performance-baseline-{id}.json`
- Parallelization plan: `.claude/context/artifacts/parallel-execution-plan-{id}.json`
- Checkpoint config: `.claude/context/artifacts/checkpoint-config-{id}.json`
- Resource config: `.claude/context/artifacts/resource-config-{id}.json`
- Performance report: `.claude/context/artifacts/performance-results-{id}.json`

## Success Criteria

| Criterion | Measurement | Target |
|-----------|-------------|--------|
| Baseline metrics captured | Performance baseline artifact | Baseline metrics documented |
| Parallel opportunities identified | Parallelization plan | Independent steps identified |
| Parallel execution works | Execution validation | Independent steps execute in parallel |
| Checkpoint overhead reduced | Checkpoint timing comparison | >= 30% reduction |
| Workflow time reduced | Total execution time comparison | >= 40% reduction |
| No concurrency bugs | Concurrency testing | No race conditions detected |
| Checkpoint integrity maintained | Checkpoint validation | Integrity verified after recovery |
| Resource usage within limits | Resource monitoring | Memory, CPU within configured limits |

## Optimization Techniques

### 1. Parallel Agent Execution
```yaml
# Execute independent steps in parallel
parallel_groups:
  - name: "Analysis Phase"
    steps: [analyst, pm, ux-expert]
    synchronization: wait_all
  - name: "Code Review"
    steps: [code-reviewer, security-architect]
    synchronization: wait_all
```

### 2. Checkpoint Optimization
```yaml
checkpoint_strategy:
  frequency: "on_step_completion"
  compression: true
  incremental: true
  max_size_mb: 5
  retention_policy:
    keep_last_n: 3
    ttl_hours: 24
```

### 3. Resource Management
```yaml
resource_limits:
  max_concurrent_agents: 5
  agent_timeout_ms: 300000
  context_cache_size_mb: 100
  lazy_artifact_loading: true
```

### 4. Context Optimization
- Lazy-load artifacts only when needed
- Cache frequently accessed files
- Implement progressive disclosure for large artifacts
- Use artifact references instead of full content

## Performance Metrics

**Baseline Metrics**:
- Total workflow execution time
- Per-step execution time
- Checkpoint save/restore time
- Context loading time
- Resource usage (memory, CPU)

**Target Improvements**:
- 40% reduction in total execution time
- 30% reduction in checkpoint overhead
- 50% reduction in context loading time
- 20% reduction in resource usage

## Test Scenarios

### Scenario 1: Parallel Execution
```
1. Execute greenfield-fullstack workflow sequentially (baseline)
2. Identify independent steps (Step 2: analyst, pm, ux-expert)
3. Execute independent steps in parallel
4. Measure time savings
5. Verify correctness of parallel execution
Expected: 30-40% time reduction for analysis phase
```

### Scenario 2: Checkpoint Optimization
```
1. Measure baseline checkpoint save time (10 steps)
2. Enable checkpoint compression
3. Implement incremental checkpoints
4. Measure optimized checkpoint save time
Expected: 30-50% reduction in checkpoint overhead
```

### Scenario 3: Resource Management
```
1. Measure baseline resource usage
2. Implement agent pooling (max 5 concurrent)
3. Enable lazy artifact loading
4. Measure optimized resource usage
Expected: 20-30% reduction in memory usage
```

## Example Prompts
```
"Optimize the performance of greenfield-fullstack workflow"
"Implement parallel execution for independent workflow steps"
"Reduce checkpoint overhead in workflows"
"Profile and optimize workflow resource usage"
```

## Related Documentation
- [performance-flow.yaml](../../workflows/performance-flow.yaml)
- [Performance-Engineer Agent](../../agents/performance-engineer.md)
- [recovery Skill](../../skills/recovery/SKILL.md)
- [WORKFLOW-GUIDE.md](../../workflows/WORKFLOW-GUIDE.md)
- [CUJ-058: Error Recovery](./CUJ-058.md)

## Error Recovery

### Retry Strategy
- **Max Retries**: 3 attempts per step
- **Backoff**: Exponential (1s, 2s, 4s)
- **Retry Triggers**: Transient failures, timeouts, rate limits

### Rollback Procedures
1. **Partial Completion**: Save checkpoint to `.claude/context/runs/{{run_id}}/checkpoint.json`
2. **Failed Validation**: Return to previous passing gate (rollback optimization changes)
3. **Critical Failure**: Escalate to human with full context

### Fallback Options
- **Alternative Agent**: If primary agent fails 3x, route to backup agent
  - Performance-Engineer → Developer (optimization implementation fallback)
  - Architect → Performance-Engineer (parallelization design fallback)
  - QA → Performance-Engineer (validation fallback)
- **Manual Override**: User can force-proceed with documented risks
- **Graceful Degradation**: Apply partial optimizations with reduced performance gains

### Recovery Artifacts
- Error log: `.claude/context/runs/{{run_id}}/errors.log`
- Recovery state: `.claude/context/runs/{{run_id}}/recovery-state.json`
- Checkpoint: `.claude/context/runs/{{run_id}}/checkpoint.json`
- Baseline metrics: `.claude/context/runs/{{run_id}}/baseline-metrics.json`

## Implementation Checklist

- [ ] Baseline performance metrics established
- [ ] Parallel execution groups defined
- [ ] Agent dependencies mapped
- [ ] Checkpoint strategy optimized
- [ ] Resource limits configured
- [ ] Lazy artifact loading implemented
- [ ] Performance monitoring added
- [ ] Performance tests created
- [ ] Validation tests passed
- [ ] Documentation updated
