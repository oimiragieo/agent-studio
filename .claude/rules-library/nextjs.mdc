---
description: Next.js with TypeScript and Tailwind UI best practices
globs: **/*.tsx, **/*.ts, src/**/*.ts, src/**/*.tsx
---

# Next.js Best Practices

## Project Structure
- Use the App Router directory structure
- Place components in `app` directory for route-specific components
- Place shared components in `components` directory
- Place utilities and helpers in `lib` directory
- Use lowercase with dashes for directories (e.g., `components/auth-wizard`)

## Components
- Use Server Components by default
- Mark client components explicitly with 'use client'
- Wrap client components in Suspense with fallback
- Use dynamic loading for non-critical components
- Implement proper error boundaries
- Place static content and interfaces at file end

## Performance
- Optimize images: Use WebP format, size data, lazy loading
- Minimize use of 'useEffect' and 'setState'
- Favor Server Components (RSC) where possible
- Use dynamic loading for non-critical components
- Implement proper caching strategies

## Data Fetching
- Use Server Components for data fetching when possible
- Implement proper error handling for data fetching
- Use appropriate caching strategies
- Handle loading and error states appropriately

## Routing
- Use the App Router conventions
- Implement proper loading and error states for routes
- Use dynamic routes appropriately
- Handle parallel routes when needed

## Forms and Validation
- Use Zod for form validation
- Implement proper server-side validation
- Handle form errors appropriately
- Show loading states during form submission

## State Management
- Minimize client-side state
- Use React Context sparingly
- Prefer server state when possible
- Implement proper loading states

## Templates

<template name="component">
import { Suspense } from 'react'

interface {{Name}}Props {
  // Add props here
}

export default function {{Name}}({ }: {{Name}}Props) {
  return (
    <Suspense fallback={<p>Loading...</p>}>
      {/* Component content */}
    </Suspense>
  )
}
</template>

<template name="api-route">
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  try {
    // Add GET handler logic
    return NextResponse.json({ success: true })
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    // Add POST handler logic
    return NextResponse.json({ success: true }, { status: 201 })
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</template>

## Validation

<validation>
forbidden_patterns:
  - pattern: "useEffect\\(.*fetch"
    message: "Do not use useEffect for data fetching; use Server Components."
    severity: "error"
  - pattern: "console\\.log"
    message: "Remove console.log before commit."
    severity: "warning"
  - pattern: "'use client'.*fetch"
    message: "Avoid data fetching in client components; prefer Server Components."
    severity: "warning"
  - pattern: "useState.*fetch"
    message: "Do not use useState with fetch; use Server Components for data fetching."
    severity: "error"
</validation>