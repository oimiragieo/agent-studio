---
description: Python best practices and patterns for modern software development with Flask and SQLite
globs: **/*.py, src/**/*.py, tests/**/*.py
---

# Python Best Practices

## Project Structure
- Use src-layout with `src/your_package_name/`
- Place tests in `tests/` directory parallel to `src/`
- Keep configuration in `config/` or as environment variables
- Store requirements in `requirements.txt` or `pyproject.toml`
- Place static files in `static/` directory
- Use `templates/` for Jinja2 templates

## Code Style
- Follow Black code formatting
- Use isort for import sorting
- Follow PEP 8 naming conventions:
  - snake_case for functions and variables
  - PascalCase for classes
  - UPPER_CASE for constants
- Maximum line length of 88 characters (Black default)
- Use absolute imports over relative imports

## Type Hints
- Use type hints for all function parameters and returns
- Import types from `typing` module
- Use `Optional[Type]` instead of `Type | None`
- Use `TypeVar` for generic types
- Define custom types in `types.py`
- Use `Protocol` for duck typing

## Flask Structure
- Use Flask factory pattern
- Organize routes using Blueprints
- Use Flask-SQLAlchemy for database
- Implement proper error handlers
- Use Flask-Login for authentication
- Structure views with proper separation of concerns

## Database
- Use SQLAlchemy ORM
- Implement database migrations with Alembic
- Use proper connection pooling
- Define models in separate modules
- Implement proper relationships
- Use proper indexing strategies

## Authentication
- Use Flask-Login for session management
- Implement Google OAuth using Flask-OAuth
- Hash passwords with bcrypt
- Use proper session security
- Implement CSRF protection
- Use proper role-based access control

## API Design
- Use Flask-RESTful for REST APIs
- Implement proper request validation
- Use proper HTTP status codes
- Handle errors consistently
- Use proper response formats
- Implement proper rate limiting

## Testing
- Use pytest for testing
- Write tests for all routes
- Use pytest-cov for coverage
- Implement proper fixtures
- Use proper mocking with pytest-mock
- Test all error scenarios

## Security
- Use HTTPS in production
- Implement proper CORS
- Sanitize all user inputs
- Use proper session configuration
- Implement proper logging
- Follow OWASP guidelines

## Performance
- Use proper caching with Flask-Caching
- Implement database query optimization
- Use proper connection pooling
- Implement proper pagination
- Use background tasks for heavy operations
- Monitor application performance

## Error Handling
- Create custom exception classes
- Use proper try-except blocks
- Implement proper logging
- Return proper error responses
- Handle edge cases properly
- Use proper error messages

## Documentation
- Use Google-style docstrings
- Document all public APIs
- Keep README.md updated
- Use proper inline comments
- Generate API documentation
- Document environment setup

## Development Workflow
- Use virtual environments (venv)
- Implement pre-commit hooks
- Use proper Git workflow
- Follow semantic versioning
- Use proper CI/CD practices
- Implement proper logging

## Templates

<template name="api-endpoint">
"""{{description}}"""
from typing import Optional, Dict, Any
from fastapi import APIRouter, HTTPException, status
from pydantic import BaseModel

router = APIRouter()


class {{Name}}Request(BaseModel):
    """Request model for {{name}} endpoint."""
    # Add request fields here
    pass


class {{Name}}Response(BaseModel):
    """Response model for {{name}} endpoint."""
    # Add response fields here
    success: bool
    message: str


@router.post("/{{route_path}}", response_model={{Name}}Response)
async def {{name}}(request: {{Name}}Request) -> Dict[str, Any]:
    """
    {{description}}

    Args:
        request: The {{name}} request payload

    Returns:
        {{Name}}Response with operation status

    Raises:
        HTTPException: If operation fails
    """
    try:
        # Add endpoint logic here
        return {{Name}}Response(
            success=True,
            message="Operation completed successfully"
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Operation failed: {str(e)}"
        )
</template>

<template name="class">
"""{{description}}"""
from typing import Optional, Any


class {{Name}}:
    """
    {{description}}

    Attributes:
        # Add attributes here

    Example:
        >>> obj = {{Name}}()
        >>> obj.method()
    """

    def __init__(self, *args, **kwargs) -> None:
        """
        Initialize {{Name}} instance.

        Args:
            *args: Positional arguments
            **kwargs: Keyword arguments
        """
        # Add initialization logic here
        pass

    def __repr__(self) -> str:
        """Return string representation of {{Name}}."""
        return f"{{Name}}()"

    def __str__(self) -> str:
        """Return human-readable string representation."""
        return self.__repr__()
</template>

<template name="test">
"""Tests for {{module_name}}."""
import pytest
from {{module_path}} import {{Name}}


@pytest.fixture
def {{name}}_instance():
    """
    Fixture providing {{Name}} instance for tests.

    Returns:
        {{Name}}: Configured {{Name}} instance
    """
    return {{Name}}()


class Test{{Name}}:
    """Test suite for {{Name}} class."""

    def test_{{name}}_initialization(self, {{name}}_instance):
        """Test {{Name}} initializes correctly."""
        assert {{name}}_instance is not None
        # Add initialization assertions here

    def test_{{name}}_method(self, {{name}}_instance):
        """Test {{Name}} method works correctly."""
        # Add method test logic here
        result = {{name}}_instance.method()
        assert result is not None

    def test_{{name}}_edge_case(self, {{name}}_instance):
        """Test {{Name}} handles edge cases."""
        # Add edge case test logic here
        with pytest.raises(ValueError):
            {{name}}_instance.invalid_operation()

    def test_{{name}}_error_handling(self, {{name}}_instance):
        """Test {{Name}} error handling."""
        # Add error handling test logic here
        pass
</template>

## Dependencies
- Pin dependency versions
- Use requirements.txt for production
- Separate dev dependencies
- Use proper package versions
- Regularly update dependencies
- Check for security vulnerabilities

## Validation

<validation>
forbidden_patterns:
  - pattern: "print\\("
    message: "Use logging instead of print statements"
    severity: "warning"
    fix: "Replace print() with logging.info(), logging.debug(), logging.warning(), or logging.error() depending on the context. Import logging module at the top of the file."
  - pattern: "except\\s*:"
    message: "Specify exception types in except clauses"
    severity: "error"
    fix: "Replace 'except:' with 'except SpecificException:' or 'except Exception as e:' to catch all exceptions explicitly. Never use bare except clauses."
  - pattern: "eval\\("
    message: "Never use eval() for security reasons"
    severity: "error"
    fix: "Remove eval() entirely. Use ast.literal_eval() for safe evaluation of literals, or json.loads() for JSON data. For dynamic code execution, refactor to use proper control flow."
  - pattern: "exec\\("
    message: "Never use exec() for security reasons"
    severity: "error"
    fix: "Remove exec() and refactor code to use proper Python constructs. Consider using importlib for dynamic imports, or refactor logic to avoid dynamic code execution."
  - pattern: "import \\*"
    message: "Avoid wildcard imports"
    severity: "warning"
    fix: "Replace 'from module import *' with explicit imports: 'from module import SpecificClass, specific_function'. List only the items you need."
</validation>