---
description: TypeScript coding standards and best practices for modern web development
globs: **/*.ts, **/*.tsx, **/*.d.ts
priority: medium
---

<template name="interface">
/**
 * {{description}}
 *
 * @example
 * const {{name}}: {{Name}} = {
 *   id: '123',
 *   // ... additional properties
 * };
 */
export interface {{Name}} {
  /** Unique identifier */
  id: string;
  /** Creation timestamp */
  createdAt: Date;
  /** Last update timestamp */
  updatedAt: Date;
  // Add additional properties with proper types
}
</template>

<template name="type">
/**
 * {{description}}
 *
 * @example
 * const {{name}}: {{Name}} = 'option_a';
 */
export type {{Name}} =
  | 'option_a'
  | 'option_b'
  | 'option_c';

/**
 * Type guard to check if value is a valid {{Name}}
 */
export function is{{Name}}(value: unknown): value is {{Name}} {
  return typeof value === 'string' &&
    ['option_a', 'option_b', 'option_c'].includes(value);
}
</template>

<template name="utility">
/**
 * {{description}}
 *
 * @param {{paramName}} - {{paramDescription}}
 * @returns {{returnDescription}}
 * @throws {Error} {{errorDescription}}
 *
 * @example
 * const result = {{name}}(inputValue);
 */
export function {{name}}<T extends Record<string, unknown>>(
  {{paramName}}: T
): Promise<{{ReturnType}}> {
  try {
    // Input validation
    if (!{{paramName}}) {
      throw new Error('{{paramName}} is required');
    }

    // Implementation logic here
    const result: {{ReturnType}} = {
      // Process and return result
    };

    return Promise.resolve(result);
  } catch (error) {
    // Type-safe error handling
    const errorMessage = error instanceof Error
      ? error.message
      : 'Unknown error occurred';

    throw new Error(`Failed to {{name}}: ${errorMessage}`);
  }
}
</template>

<template name="enum-alternative">
/**
 * {{description}} - Use const object instead of enum
 *
 * @example
 * const status = {{Name}}.OPTION_A;
 */
export const {{Name}} = {
  OPTION_A: 'option_a',
  OPTION_B: 'option_b',
} as const;

export type {{Name}}Type = typeof {{Name}}[keyof typeof {{Name}}];
</template>

# TypeScript Best Practices

## Type System
- Prefer interfaces over types for object definitions
- Use type for unions, intersections, and mapped types
- Avoid using `any`, prefer `unknown` for unknown types
- Use strict TypeScript configuration
- Leverage TypeScript's built-in utility types
- Use generics for reusable type patterns

## Naming Conventions
- Use PascalCase for type names and interfaces
- Use camelCase for variables and functions
- Use UPPER_CASE for constants
- Use descriptive names with auxiliary verbs (e.g., isLoading, hasError)
- Prefix interfaces for React props with 'Props' (e.g., ButtonProps)

## Code Organization
- Keep type definitions close to where they're used
- Export types and interfaces from dedicated type files when shared
- Use barrel exports (index.ts) for organizing exports
- Place shared types in a `types` directory
- Co-locate component props with their components

## Functions
- Use explicit return types for public functions
- Use arrow functions for callbacks and methods
- Implement proper error handling with custom error types
- Use function overloads for complex type scenarios
- Prefer async/await over Promises

## Best Practices
- Enable strict mode in tsconfig.json
- Use readonly for immutable properties
- Leverage discriminated unions for type safety
- Use type guards for runtime type checking
- Implement proper null checking
- Avoid type assertions unless necessary

## Error Handling
- Create custom error types for domain-specific errors
- Use Result types for operations that can fail
- Implement proper error boundaries
- Use try-catch blocks with typed catch clauses
- Handle Promise rejections properly

## Patterns
- Use the Builder pattern for complex object creation
- Implement the Repository pattern for data access
- Use the Factory pattern for object creation
- Leverage dependency injection
- Use the Module pattern for encapsulation

## Validation

<validation>
forbidden_patterns:
  - pattern: ":\\s*any\\b"
    message: "Avoid 'any' type; use 'unknown' or specific types"
    severity: "error"
  - pattern: "@ts-ignore"
    message: "Fix type errors instead of ignoring them"
    severity: "warning"
  - pattern: "\\.innerHTML\\s*="
    message: "Avoid innerHTML; use safe DOM methods"
    severity: "error"
  - pattern: "as any"
    message: "Avoid casting to 'any'"
    severity: "warning"
</validation>