---
description: React best practices and patterns for modern web applications
globs: **/*.tsx, **/*.jsx, components/**/*
---

# React Best Practices

## Component Structure
- Use functional components over class components
- Keep components small and focused
- Extract reusable logic into custom hooks
- Use composition over inheritance
- Implement proper prop types with TypeScript
- Split large components into smaller, focused ones

## Hooks
- Follow the Rules of Hooks
- Use custom hooks for reusable logic
- Keep hooks focused and simple
- Use appropriate dependency arrays in useEffect
- Implement cleanup in useEffect when needed
- Avoid nested hooks

## State Management
- Use useState for local component state
- Implement useReducer for complex state logic
- Use Context API for shared state
- Keep state as close to where it's used as possible
- Avoid prop drilling through proper state management
- Use state management libraries only when necessary

## Performance
- Implement proper memoization (useMemo, useCallback)
- Use React.memo for expensive components
- Avoid unnecessary re-renders
- Implement proper lazy loading
- Use proper key props in lists
- Profile and optimize render performance

## Forms
- Use controlled components for form inputs
- Implement proper form validation
- Handle form submission states properly
- Show appropriate loading and error states
- Use form libraries for complex forms
- Implement proper accessibility for forms

## Error Handling
- Implement Error Boundaries
- Handle async errors properly
- Show user-friendly error messages
- Implement proper fallback UI
- Log errors appropriately
- Handle edge cases gracefully

## Testing
- Write unit tests for components
- Implement integration tests for complex flows
- Use React Testing Library
- Test user interactions
- Test error scenarios
- Implement proper mock data

## Accessibility
- Use semantic HTML elements
- Implement proper ARIA attributes
- Ensure keyboard navigation
- Test with screen readers
- Handle focus management
- Provide proper alt text for images

## Code Organization
- Group related components together
- Use proper file naming conventions
- Implement proper directory structure
- Keep styles close to components
- Use proper imports/exports
- Document complex component logic

## Templates

<template name="component">
import React, { memo } from 'react'

/**
 * {{description}}
 *
 * @example
 * ```tsx
 * <{{Name}} />
 * ```
 */
interface {{Name}}Props {
  /** Description of prop */
  className?: string
  children?: React.ReactNode
}

/**
 * {{Name}} component
 *
 * {{description}}
 */
export const {{Name}} = memo<{{Name}}Props>(({
  className,
  children
}) => {
  return (
    <div className={className}>
      {children}
    </div>
  )
})

{{Name}}.displayName = '{{Name}}'
</template>

<template name="hook">
import { useState, useEffect, useCallback } from 'react'

/**
 * {{description}}
 *
 * @example
 * ```tsx
 * const { {{name}}, loading, error } = use{{Name}}()
 * ```
 */
interface Use{{Name}}Result {
  /** The current {{name}} data */
  {{name}}: {{Type}} | null
  /** Loading state */
  loading: boolean
  /** Error state */
  error: Error | null
  /** Refresh the data */
  refresh: () => void
}

/**
 * Custom hook for {{description}}
 *
 * @returns {{Use{{Name}}Result}} The hook result object
 */
export function use{{Name}}(): Use{{Name}}Result {
  const [{{name}}, set{{Name}}] = useState<{{Type}} | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  const fetch{{Name}} = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)
      // Add fetch logic here
      // const data = await fetchData()
      // set{{Name}}(data)
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Unknown error'))
    } finally {
      setLoading(false)
    }
  }, [])

  useEffect(() => {
    fetch{{Name}}()
  }, [fetch{{Name}}])

  const refresh = useCallback(() => {
    fetch{{Name}}()
  }, [fetch{{Name}}])

  return { {{name}}, loading, error, refresh }
}
</template>

<template name="context">
import React, { createContext, useContext, useState, useCallback, useMemo } from 'react'

/**
 * {{description}}
 */
interface {{Name}}ContextValue {
  /** Current {{name}} state */
  {{name}}: {{Type}}
  /** Update the {{name}} */
  set{{Name}}: ({{name}}: {{Type}}) => void
  /** Reset {{name}} to default */
  reset{{Name}}: () => void
}

/**
 * Props for {{Name}}Provider
 */
interface {{Name}}ProviderProps {
  /** Child components */
  children: React.ReactNode
  /** Initial {{name}} value */
  initialValue?: {{Type}}
}

// Create context with undefined default (requires provider)
const {{Name}}Context = createContext<{{Name}}ContextValue | undefined>(undefined)

const DEFAULT_{{NAME}}: {{Type}} = {
  // Add default value here
}

/**
 * Provider component for {{Name}} context
 *
 * @example
 * ```tsx
 * <{{Name}}Provider>
 *   <App />
 * </{{Name}}Provider>
 * ```
 */
export function {{Name}}Provider({
  children,
  initialValue = DEFAULT_{{NAME}}
}: {{Name}}ProviderProps) {
  const [{{name}}, set{{Name}}State] = useState<{{Type}}>(initialValue)

  const set{{Name}} = useCallback((newValue: {{Type}}) => {
    set{{Name}}State(newValue)
  }, [])

  const reset{{Name}} = useCallback(() => {
    set{{Name}}State(DEFAULT_{{NAME}})
  }, [])

  const value = useMemo(
    () => ({ {{name}}, set{{Name}}, reset{{Name}} }),
    [{{name}}, set{{Name}}, reset{{Name}}]
  )

  return (
    <{{Name}}Context.Provider value={value}>
      {children}
    </{{Name}}Context.Provider>
  )
}

/**
 * Hook to use {{Name}} context
 *
 * @throws {Error} If used outside of {{Name}}Provider
 * @returns {{{Name}}ContextValue} The context value
 *
 * @example
 * ```tsx
 * function MyComponent() {
 *   const { {{name}}, set{{Name}} } = use{{Name}}()
 *   return <div>{{{name}}}</div>
 * }
 * ```
 */
export function use{{Name}}(): {{Name}}ContextValue {
  const context = useContext({{Name}}Context)

  if (context === undefined) {
    throw new Error('use{{Name}} must be used within a {{Name}}Provider')
  }

  return context
}
</template>

## Validation

<validation>
forbidden_patterns:
  - pattern: "useEffect\\([^)]*\\[\\]\\s*\\)"
    message: "Empty dependency array may cause stale closures"
    severity: "warning"
    fix: "Review the useEffect dependencies and include all values from component scope that are used inside the effect. If the effect should only run once on mount, verify that it doesn't reference any props or state that could change."
  - pattern: "dangerouslySetInnerHTML"
    message: "Avoid dangerouslySetInnerHTML; sanitize if necessary"
    severity: "warning"
    fix: "Remove dangerouslySetInnerHTML and render content safely using JSX. If HTML content is unavoidable, sanitize it using a library like DOMPurify before rendering: dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(htmlContent) }}"
  - pattern: "document\\.(getElementById|querySelector)"
    message: "Use React refs instead of direct DOM access"
    severity: "warning"
    fix: "Replace direct DOM access with React refs. Create a ref using useRef() hook, attach it to the element with the ref prop, and access the DOM node via ref.current. Example: const myRef = useRef<HTMLDivElement>(null); <div ref={myRef}>..."
</validation>