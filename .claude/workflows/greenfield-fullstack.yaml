name: Greenfield Full-Stack Development Workflow
description: Complete workflow for building a new full-stack application from scratch
type: greenfield
project_type: fullstack
publish_policy: auto-on-pass # Automatically publish artifacts after validation passes

# Error Recovery Configuration
recovery:
  enabled: true
  checkpoint_dir: '.claude/context/runtime/runs/{{run_id}}/checkpoints'

retry_config:
  max_attempts: 3
  backoff_strategy: exponential
  initial_delay_ms: 1000
  retryable_errors: [timeout, network_error, rate_limit]

fallback_agents:
  developer: [code-reviewer, qa]
  architect: [developer, security-architect]
  qa: [developer, code-reviewer]
  planner: [architect, pm]
  business-analyst: [pm, architect]
  pm: [business-analyst, ux-expert]
  ux-expert: [pm, accessibility-expert]
  database-architect: [architect, developer]
  security-architect: [compliance-auditor, code-reviewer]
  accessibility-expert: [ux-expert, qa]
  performance-engineer: [developer, architect]
  devops: [architect, developer]
  cloud-integrator: [devops, developer]
  model-orchestrator: [code-reviewer, qa]
  code-reviewer: [developer, security-architect]
  code-simplifier: [code-reviewer, developer]
  technical-writer: [developer, pm]
  gcp-cloud-agent: [devops, cloud-integrator]

# NOTE: This workflow is selected via keywords defined in .claude/config.yaml workflow_selection section.
# The routing system matches user prompts against keywords in config.yaml, not this file.
# See .claude/config.yaml for the authoritative keyword list used by the routing system.

# Parallel Execution Configuration
# Steps with the same parallel_group execute concurrently for 67% time savings
# See .claude/tools/workflow/parallel-executor.mjs for implementation
parallel_execution:
  enabled: true
  fail_fast: false # Continue with other parallel steps even if one fails
  timeout_per_step: 300000 # 5 minutes per step

steps:
  - step: 0
    name: 'Planning Phase'
    agent: planner
    inputs:
      - user_requirements (or features-distilled.json from step 0.5 if file > 15KB)
      - features-distilled.json (from step 0.5, if available)
      - business_objectives
    outputs:
      - plan-{{workflow_id}}.md
      - plan-{{workflow_id}}.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/00-planner.json
    validation:
      schema: .claude/schemas/plan.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/00-planner.json
    description: |
      Comprehensive planning before execution:
      - Analyze requirements and objectives
      - Coordinate with specialists for planning input
      - Generate structured plan with steps, dependencies, risks
      - Validate plan completeness and feasibility
      - Note: If user_requirements is a markdown file > 15KB, Step 0.5 (Feature Distillation) executes first
      - **Publishing**: After validation, use `artifact-publisher` skill to publish plan artifacts to project feed

  - step: 0.1
    name: 'Plan Rating Gate'
    agent: orchestrator
    type: validation
    skill: response-rater
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
    outputs:
      - .claude/context/runtime/runs/{{run_id}}/plans/{{plan_id}}-rating.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/00.1-orchestrator.json
    validation:
      minimum_score: 7
      rubric_file: .claude/context/artifacts/standard-plan-rubric.json
      schema: .claude/schemas/plan-rating.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/00.1-orchestrator.json
    retry:
      max_attempts: 3
      on_failure: escalate_to_human
    description: |
      Rate plan quality using response-rater skill.
      - Rubric: completeness, feasibility, risk mitigation, agent coverage, integration
      - Minimum passing score: 7/10
      - If score < 7: Return to Planner with feedback, request improvements, re-rate until passing
      - If score >= 7: Proceed with workflow execution
      - Log rating in reasoning file and artifact metadata
      - Never execute an unrated plan - this is a hard requirement

  - step: 0.5
    publish_targets: ['project_feed', 'cursor']
    name: 'Feature Distillation'
    agent: business-analyst
    condition: 'file_size(user_requirements) > 15KB'
    inputs:
      - user_requirements (markdown file)
    outputs:
      - features-distilled.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/00.5-business-analyst.json
    validation:
      schema: .claude/schemas/features_distilled.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/00.5-business-analyst.json
      custom_checks:
        - all_critical_features_preserved
        - acceptance_criteria_included
        - dependencies_mapped
    description: |
      Distill large markdown feature documents into structured JSON:
      - Extract feature list from markdown
      - Summarize each feature while preserving critical details
      - Create structured JSON output for Planner
      - Only executes if input file > 15KB (checked by workflow_runner.js)
      - Output: features-distilled.json passed to Step 0 (Planner) instead of raw markdown

  - step: 1
    publish_targets: ['project_feed', 'cursor']
    name: 'Project Discovery'
    agent: business-analyst
    parallel: true
    parallel_group: 1 # Parallel group 1: Discovery + PRD + UX
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - user_requirements
      - business_objectives
    outputs:
      - project-brief.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/01-business-analyst.json
    validation:
      schema: .claude/schemas/project_brief.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/01-business-analyst.json

  - step: 2
    publish_targets: ['project_feed', 'cursor']
    name: 'Product Requirements'
    agent: pm
    parallel: true
    parallel_group: 1 # Parallel group 1: Discovery + PRD + UX
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - project-brief.json (from step 1, optional) # Optional since parallel
    outputs:
      - prd.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/02-pm.json
    validation:
      schema: .claude/schemas/product_requirements.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/02-pm.json

  - step: 3
    publish_targets: ['project_feed', 'cursor']
    name: 'UX Design'
    agent: ux-expert
    parallel: true
    parallel_group: 1 # Parallel group 1: Discovery + PRD + UX
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - prd.json (from step 2, optional) # Optional since parallel
    outputs:
      - ux-spec.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/03-ux-expert.json
    validation:
      schema: .claude/schemas/ux_spec.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/03-ux-expert.json

  - step: 3.1
    name: 'Accessibility Review'
    agent: accessibility-expert
    condition: 'plan includes UI components'
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - ux-spec.json (from step 3)
      - prd.json (from step 2)
    outputs:
      - accessibility-requirements-{{workflow_id}}.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/03.1-accessibility-expert.json
    validation:
      schema: .claude/schemas/accessibility-requirements.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/03.1-accessibility-expert.json
    description: |
      Review UX design for accessibility compliance:
      - Evaluate WCAG 2.1 Level AA compliance
      - Review keyboard navigation patterns
      - Check screen reader compatibility
      - Validate color contrast ratios
      - Review focus management and ARIA attributes
      - Generate accessibility requirements for implementation
      - Only executes if plan includes UI components

  - step: 4
    publish_targets: ['project_feed', 'cursor']
    name: 'System Architecture'
    agent: architect
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - prd.json (from step 2)
      - ux-spec.json (from step 3)
    outputs:
      - system-architecture.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/04-architect.json
    validation:
      schema: .claude/schemas/system_architecture.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/04-architect.json
    description: |
      Design system architecture:
      - Create technical architecture document
      - Define system components and interactions
      - Specify technology choices
      - **Publishing**: After validation, use `artifact-publisher` skill to publish system-architecture.json to project feed (critical for Factory Droids)

  - step: 4.1
    name: 'Security Architecture Review'
    agent: security-architect
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - system-architecture.json (from step 4)
      - prd.json (from step 2)
    outputs:
      - security-architecture-{{workflow_id}}.json
      - threat-model-{{workflow_id}}.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/04.1-security-architect.json
    validation:
      schema: .claude/schemas/security-architecture.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/04.1-security-architect.json
    description: |
      Review system architecture for security considerations:
      - Identify authentication and authorization requirements
      - Create threat model with attack vectors and mitigations
      - Review data protection and encryption requirements
      - Define security controls and compliance requirements
      - Specify secure communication patterns
      - Generate security architecture requirements for implementation

  - step: 4.2
    name: 'Performance Requirements'
    agent: performance-engineer
    condition: 'plan.complexity >= moderate'
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - system-architecture.json (from step 4)
      - prd.json (from step 2)
    outputs:
      - performance-requirements-{{workflow_id}}.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/04.2-performance-engineer.json
    validation:
      schema: .claude/schemas/performance-requirements.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/04.2-performance-engineer.json
    description: |
      Define performance requirements and benchmarks:
      - Establish performance baselines and targets
      - Define Core Web Vitals thresholds (LCP, FID, CLS)
      - Specify API response time requirements
      - Define scalability requirements
      - Identify performance-critical paths
      - Create performance testing strategy
      - Only executes if plan complexity is moderate or higher

  - step: 4.5
    name: 'Infrastructure Resource Definition'
    agent: devops
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - system-architecture.json (from step 4)
      - prd.json (from step 2)
    outputs:
      - infrastructure-config.json
      - terraform-plan.json
      - deployment-config.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/04.5-devops.json
    validation:
      schema: .claude/schemas/infrastructure_config.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/04.5-devops.json
      security_checks:
        - no_hardcoded_secrets
        - all_secrets_use_references
        - resource_names_have_suffixes
        - connection_strings_use_placeholders
    description: |
      Define concrete infrastructure resources:
      - Convert logical architecture (e.g., "Object Storage") to concrete resources (e.g., "google_storage_bucket: app-assets-{env}-{unique_suffix}")
      - Generate resource names with unique suffixes to prevent global namespace collisions (critical for GCP buckets)
      - Use naming strategy: unique_hash (recommended), project_id, uuid, or deterministic
      - Generate connection strings with placeholders for secrets (never include actual passwords)
      - Create Secret Manager references for all sensitive values (passwords, API keys, tokens)
      - Generate service account configurations
      - Create Terraform plan or infrastructure-as-code definitions
      - Define environment variables and configuration values
      - Output infrastructure-config.json with all concrete resource details and secret references
      - Note: This defines resources but does NOT deploy them yet
      - Validation: All resource names include unique suffixes, all secrets use references (never actual values)

  - step: 5
    name: 'Database Architecture'
    agent: database-architect
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - system-architecture.json (from step 4)
      - infrastructure-config.json (from step 4.5)
      - prd.json (from step 2)
    outputs:
      - database-architecture.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/05-database-architect.json
    validation:
      schema: .claude/schemas/database_architecture.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/05-database-architect.json

  - step: 6
    name: 'Test Planning'
    agent: qa
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - system-architecture.json (from step 4)
      - infrastructure-config.json (from step 4.5)
      - database-architecture.json (from step 5)
      - prd.json (from step 2)
    outputs:
      - test-plan.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/06-qa.json
    validation:
      schema: .claude/schemas/test_plan.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/06-qa.json

  - step: 7
    name: 'Implementation'
    agent: developer
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - system-architecture.json (from step 4)
      - infrastructure-config.json (from step 4.5)
      - database-architecture.json (from step 5)
      - ux-spec.json (from step 3)
      - test-plan.json (from step 6)
    outputs:
      - dev-manifest.json
      - code-artifacts
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/07-developer.json
    validation:
      schema: .claude/schemas/artifact_manifest.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/07-developer.json
    description: |
      Business logic implementation:
      - Implement UI components, API routes, and core features
      - Create interfaces/stubs for cloud services (delegated to cloud-integrator)
      - Focus on application logic, not cloud integration
      - Use infrastructure-config.json for resource names and connection strings

  - step: 7.5
    name: 'Cloud Integration'
    agent: cloud-integrator
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - system-architecture.json (from step 4)
      - infrastructure-config.json (from step 4.5)
      - dev-manifest.json (from step 7)
    outputs:
      - cloud-integration.json
      - code-artifacts
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/07.5-cloud-integrator.json
    validation:
      schema: .claude/schemas/cloud_integration.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/07.5-cloud-integrator.json
    description: |
      Cloud service integration:
      - Implement GCP/AWS/Azure client libraries
      - Configure authentication (ADC, service accounts, IAM)
      - Create cloud service modules (storage, pubsub, database)
      - Implement error handling and retry logic
      - Use infrastructure-config.json for concrete resource names
      - Support both emulators (local) and production (cloud)

  - step: 8
    name: 'Multi-AI Validation'
    agent: model-orchestrator
    tool: multi-ai-validator
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - dev-manifest.json (from step 7)
      - cloud-integration.json (from step 7.5)
      - code-artifacts (from step 7)
      - code-artifacts (from step 7.5)
    outputs:
      - validation-report.json
      - consensus-issues.json
      - disagreements.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/08-model-orchestrator.json
    validation:
      schema: .claude/schemas/multi-ai-validation.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/08-model-orchestrator.json
    description: |
      Multi-AI validation of implemented code:
      - Run validation with Cursor/Gemini/Codex validators
      - Calculate consensus on issues (2/3 agreement required)
      - Identify disagreements for human review
      - Generate validation report with consensus issues
      - Route issues to appropriate agents for fixing
      - Disagreement Resolution:
        * 2/3 agreement: Route consensus issues to Developer
        * 1/3 finding: Log as low-priority warning
        * All 3 disagree: Flag for human review

  - step: 9
    name: 'Code Review'
    agent: code-reviewer
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - dev-manifest.json (from step 7)
      - cloud-integration.json (from step 7.5)
      - system-architecture.json (from step 4)
      - database-architecture.json (from step 5)
    outputs:
      - code-review-{{workflow_id}}.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/09-code-reviewer.json
    validation:
      schema: .claude/schemas/code-review.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/09-code-reviewer.json
    on_failure: 'Return to implementation step with feedback'
    description: |
      Review greenfield implementation for quality, security, and codebase impact:
      - Verify architecture alignment with design
      - Check cloud integration patterns
      - Review security implementations
      - Validate API contracts and error handling
      - Ensure consistent code style and patterns

  - step: 9.1
    name: 'Code Simplification Review'
    agent: code-simplifier
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - dev-manifest.json (from step 7)
      - cloud-integration.json (from step 7.5)
      - code-review-{{workflow_id}}.json (from step 9)
    outputs:
      - simplification-report-{{workflow_id}}.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/09.1-code-simplifier.json
    validation:
      schema: .claude/schemas/simplification-report.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/09.1-code-simplifier.json
    on_failure: 'Return to implementation step with simplification feedback'
    description: |
      Simplification review to ensure code is understandable by all developers:
      - Measure cognitive complexity and nesting depth
      - Identify over-engineering and premature abstractions
      - Flag code that fails the "junior developer test"
      - Provide before/after transformation examples
      - Block merge if complexity score > 7/10

  - step: 10
    name: 'Documentation'
    agent: technical-writer
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - dev-manifest.json (from step 7)
      - code-review-{{workflow_id}}.json (from step 9)
      - validation-report.json (from step 8)
      - system-architecture.json (from step 4)
      - database-architecture.json (from step 5)
    outputs:
      - documentation.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/10-technical-writer.json
    validation:
      schema: .claude/schemas/documentation-bundle.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/10-technical-writer.json

  - step: 11
    name: 'Quality Assurance'
    agent: qa
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - dev-manifest.json (from step 7)
      - code-review-{{workflow_id}}.json (from step 9)
      - validation-report.json (from step 8)
      - infrastructure-config.json (from step 4.5)
      - test-plan.json (from step 6)
    outputs:
      - quality-report.json
      - test-results.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/11-qa.json
    validation:
      schema: .claude/schemas/quality-report.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/11-qa.json
    secondary_outputs:
      - artifact: test-results.json
        schema: .claude/schemas/test-results.schema.json

  - step: 12
    name: 'Infrastructure Provisioning'
    agent: gcp-cloud-agent
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - infrastructure-config.json (from step 4.5)
      - dev-manifest.json (from step 7)
      - quality-report.json (from step 11)
    outputs:
      - deployment-status.json
      - infrastructure-state.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/12-gcp-cloud-agent.json
    validation:
      schema: .claude/schemas/deployment-status.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/12-gcp-cloud-agent.json
    secondary_outputs:
      - artifact: infrastructure-state.json
        schema: .claude/schemas/infrastructure-state.schema.json
    description: |
      Provision actual infrastructure resources:
      - Execute Terraform plan or gcloud commands
      - Create GCP resources defined in infrastructure-config.json
      - Verify resource creation
      - Update infrastructure-state.json with actual resource IDs
      - Note: This step is optional and can be skipped for local development

  - step: 13
    name: 'Quality Signoff'
    agent: qa
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - quality-report.json (from step 11)
      - test-results.json (from step 11)
      - code-review-{{workflow_id}}.json (from step 9)
      - simplification-report-{{workflow_id}}.json (from step 9.1)
    outputs:
      - qa-signoff-{{workflow_id}}.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/13-qa.json
    validation:
      schema: .claude/schemas/qa-signoff.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/13-qa.json
    description: |
      Final quality signoff before deployment:
      - Review all test results and quality metrics
      - Verify test coverage meets thresholds
      - Validate no critical or high-severity issues remain
      - Confirm regression testing passed
      - Sign off on quality for deployment
      - Block deployment if quality gates not met

  - step: 14
    name: 'Security Signoff'
    agent: security-architect
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - security-architecture-{{workflow_id}}.json (from step 4.1)
      - threat-model-{{workflow_id}}.json (from step 4.1)
      - code-review-{{workflow_id}}.json (from step 9)
      - quality-report.json (from step 11)
    outputs:
      - security-signoff-{{workflow_id}}.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/14-security-architect.json
    validation:
      schema: .claude/schemas/security-signoff.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/14-security-architect.json
    description: |
      Final security signoff before deployment:
      - Review security architecture implementation
      - Verify threat model mitigations in place
      - Confirm authentication and authorization correct
      - Validate data protection and encryption
      - Check for security vulnerabilities
      - Sign off on security for deployment
      - Block deployment if security issues remain

  - step: 15
    name: 'Architecture Signoff'
    agent: architect
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
      - system-architecture.json (from step 4)
      - dev-manifest.json (from step 7)
      - code-review-{{workflow_id}}.json (from step 9)
      - quality-report.json (from step 11)
    outputs:
      - architecture-signoff-{{workflow_id}}.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/15-architect.json
    validation:
      schema: .claude/schemas/architecture-signoff.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/15-architect.json
    description: |
      Final architecture signoff before deployment:
      - Review implementation against architecture design
      - Verify design patterns correctly applied
      - Validate system components and interactions
      - Confirm technology choices align with standards
      - Check for architectural debt or anti-patterns
      - Sign off on architecture for deployment
      - Block deployment if architectural issues remain

  - step: 15.5
    name: 'Publish Artifacts'
    agent: orchestrator
    skill: artifact-publisher
    condition: "validation_status == 'pass'"
    inputs:
      - artifact-registry.json
    policy: auto-on-pass
    validation:
      schema: .claude/schemas/artifact-registry.schema.json
    retry:
      max_attempts: 3
      on_failure: log_and_continue

completion_criteria:
  - All artifacts validated against schemas
  - Quality gates passed
  - Test coverage meets threshold
  - Code follows project constitution
