name: Fallback Routing Test Workflow
description: Test workflow for validating fallback agent routing, context preservation, and error recovery
type: testing
project_type: validation
publish_policy: auto-on-pass # Automatically publish artifacts after validation passes
template: true # This is a template workflow - agent fields use {{placeholders}} for dynamic substitution

# Error Recovery Configuration
recovery:
  enabled: true
  checkpoint_dir: '.claude/context/runtime/runs/{{run_id}}/checkpoints'
  test_mode: true # Enable test mode for simulated failures

retry_config:
  max_attempts: 3
  backoff_strategy: exponential
  initial_delay_ms: 1000
  retryable_errors: [timeout, network_error, rate_limit]

# Fallback Agent Configuration (Test Scenarios)
fallback_agents:
  architect: [developer, security-architect]
  developer: [refactoring-specialist, code-reviewer]
  pm: [analyst, ux-expert]
  analyst: [pm, architect]
  database-architect: [architect, developer]
  ux-expert: [pm, accessibility-expert]
  qa: [developer, code-reviewer]
  security-architect: [compliance-auditor, code-reviewer]
  planner: [architect, pm]

# NOTE: trigger_keywords here are for documentation only.
# The actual workflow selection uses keywords from .claude/config.yaml workflow_selection section.
# See .claude/config.yaml for the authoritative keyword list used by the routing system.
trigger_keywords:
  - 'test fallback'
  - 'fallback routing'
  - 'agent fallback'
  - 'test recovery'
  - 'fallback chain'

# Workflow-Level Context Inputs
workflow_inputs:
  required:
    - test_scenario # "explicit_fallback" | "capability_matrix" | "context_preservation" | "fallback_chain" | "invalid_output"
    - primary_agent # Agent to test (e.g., "architect")
    - failure_type # "non_recoverable" | "timeout" | "invalid_output"
  optional:
    - max_fallback_attempts # Maximum fallback attempts (default: 2)

steps:
  - step: 0
    name: 'Planning Phase'
    agent: planner
    inputs:
      # Workflow-level context inputs (provided at workflow start, not artifact files)
      - test_scenario # Test scenario to execute
      - primary_agent # Primary agent to test
      - failure_type # Type of failure to simulate
      - max_fallback_attempts # (optional) Maximum fallback attempts
    outputs:
      - plan-{{workflow_id}}.md
      - plan-{{workflow_id}}.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/00-planner.json
    # Phase 2A: Skill requirements for this step
    skill_requirements:
      required:
        - plan-generator
        - sequential-thinking
      recommended:
        - diagram-generator
      triggered:
        - pattern: 'fallback|recovery|routing'
          skills: [sequential-thinking, diagram-generator]
          priority: required
      outputs:
        plan-generator:
          primary: 'plan-{{workflow_id}}.json'
          schema: '.claude/schemas/plan.schema.json'
          required_for_completion: true
      validation:
        mode: blocking
        min_compliance: 100
        on_failure: block
    validation:
      schema: .claude/schemas/plan.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/00-planner.json
    description: |
      Plan fallback routing test workflow:
      - Analyze test scenario and requirements
      - Define primary and fallback agents
      - Specify fallback routing logic
      - Define context preservation requirements
      - Create structured test plan

  - step: 0.1
    name: 'Plan Rating Gate'
    agent: orchestrator
    type: validation
    skill: response-rater
    inputs:
      - plan-{{workflow_id}}.json (from step 0)
    outputs:
      - .claude/context/runtime/runs/{{run_id}}/plans/{{plan_id}}-rating.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/00.1-orchestrator.json
    validation:
      minimum_score: 7
      rubric_file: .claude/context/artifacts/standard-plan-rubric.json
      gate: .claude/context/history/gates/{{workflow_id}}/00.1-orchestrator.json
    retry:
      max_attempts: 3
      on_failure: escalate_to_human
    description: |
      Rate plan quality using response-rater skill.
      - Rubric: completeness, feasibility, risk mitigation, agent coverage, integration
      - Minimum passing score: 7/10
      - If score < 7: Return to Planner with feedback, request improvements, re-rate until passing
      - If score >= 7: Proceed with workflow execution
      - Log rating in reasoning file and artifact metadata
      - Never execute an unrated plan - this is a hard requirement

  - step: 1
    name: 'Primary Agent Execution (Simulated Failure)'
    agent: '{{primary_agent}}' # Dynamic agent based on test scenario
    test_mode: true
    simulate_failure: true
    inputs:
      # Artifact inputs (from previous steps)
      - plan-{{workflow_id}}.json (from step 0)
      # Workflow-level context inputs (provided at workflow start, not artifact files)
      - test_scenario # Test scenario
      - failure_type # Failure type to simulate
    outputs:
      - primary-agent-artifacts-{{workflow_id}}.json (partial)
      - error-details-{{workflow_id}}.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/01-{{primary_agent}}.json
    validation:
      gate: .claude/context/history/gates/{{workflow_id}}/01-{{primary_agent}}.json
    on_failure: 'Trigger fallback routing to step 2'
    description: |
      Primary agent execution with simulated failure:
      - Primary agent receives task
      - Creates initial artifacts (partial)
      - Simulates failure based on failure_type parameter
      - Generates error details for fallback context
      - Failure types: non_recoverable, timeout, invalid_output

  - step: 2
    name: 'Failure Detection and Fallback Selection'
    agent: orchestrator
    inputs:
      # Artifact inputs (from previous steps)
      - plan-{{workflow_id}}.json (from step 0)
      - error-details-{{workflow_id}}.json (from step 1)
      # Workflow-level context inputs (provided at workflow start, not artifact files)
      - primary_agent # Primary agent that failed
      - test_scenario # Test scenario
    outputs:
      - fallback-routing-decision-{{workflow_id}}.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/02-orchestrator.json
    validation:
      schema: .claude/schemas/fallback-routing-decision.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/02-orchestrator.json
    description: |
      Failure detection and fallback agent selection:
      - Detect primary agent failure
      - Categorize failure type (non-recoverable, timeout, invalid output)
      - Check agent definition for explicit fallback_agent field
      - If not specified, use capability matrix
      - Select fallback agent based on failure type
      - Document fallback routing decision

  - step: 3
    name: 'Context Preservation Validation'
    agent: orchestrator
    inputs:
      # Artifact inputs (from previous steps)
      - plan-{{workflow_id}}.json (from step 0)
      - primary-agent-artifacts-{{workflow_id}}.json (from step 1)
      - error-details-{{workflow_id}}.json (from step 1)
      - fallback-routing-decision-{{workflow_id}}.json (from step 2)
    outputs:
      - context-package-{{workflow_id}}.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/03-orchestrator.json
    validation:
      schema: .claude/schemas/context-package.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/03-orchestrator.json
    description: |
      Validate and package context for fallback agent:
      - Preserve all artifacts from previous steps
      - Include error details from primary agent
      - Provide original task requirements
      - Include technical/business constraints
      - Document fallback reason
      - Verify fallback agent capabilities

  - step: 4
    name: 'Fallback Agent Execution'
    agent: '{{fallback_agent}}' # Dynamic agent from fallback routing decision
    inputs:
      # Artifact inputs (from previous steps)
      - plan-{{workflow_id}}.json (from step 0)
      - context-package-{{workflow_id}}.json (from step 3)
      - primary-agent-artifacts-{{workflow_id}}.json (from step 1)
      - error-details-{{workflow_id}}.json (from step 1)
    outputs:
      - fallback-agent-output-{{workflow_id}}.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/04-{{fallback_agent}}.json
    validation:
      gate: .claude/context/history/gates/{{workflow_id}}/04-{{fallback_agent}}.json
    description: |
      Fallback agent execution:
      - Fallback agent receives full context package
      - Verifies required artifacts exist
      - Verifies fallback agent has required tools/context
      - Executes task using fallback approach
      - Creates output artifacts
      - Completes task successfully

  - step: 5
    name: 'Fallback Validation'
    agent: qa
    inputs:
      # Artifact inputs (from previous steps)
      - plan-{{workflow_id}}.json (from step 0)
      - context-package-{{workflow_id}}.json (from step 3)
      - fallback-routing-decision-{{workflow_id}}.json (from step 2)
      - fallback-agent-output-{{workflow_id}}.json (from step 4)
      - error-details-{{workflow_id}}.json (from step 1)
    outputs:
      - fallback-validation-report-{{workflow_id}}.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/05-qa.json
    validation:
      schema: .claude/schemas/fallback-validation-report.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/05-qa.json
    description: |
      Validate fallback routing success:
      - Verify fallback agent received correct context
      - Verify all artifacts preserved during fallback
      - Verify error details included in context
      - Verify task requirements clear
      - Verify output quality acceptable
      - Validate fallback agent capabilities

  - step: 6
    name: 'Plan Update and Documentation'
    agent: planner
    inputs:
      # Artifact inputs (from previous steps)
      - plan-{{workflow_id}}.json (from step 0)
      - fallback-routing-decision-{{workflow_id}}.json (from step 2)
      - fallback-validation-report-{{workflow_id}}.json (from step 5)
      - fallback-agent-output-{{workflow_id}}.json (from step 4)
    outputs:
      - updated-plan-{{workflow_id}}.json
      - fallback-tracking-{{workflow_id}}.json
      - reasoning: .claude/context/history/reasoning/{{workflow_id}}/06-planner.json
    validation:
      schema: .claude/schemas/plan.schema.json
      gate: .claude/context/history/gates/{{workflow_id}}/06-planner.json
    description: |
      Update plan with fallback routing results:
      - Update plan document with fallback agent assignment
      - Document fallback reason and context
      - Update task status with fallback success/failure
      - Track fallback chain and attempts
      - Record lessons learned from fallback routing

  - step: 6.5
    name: 'Publish Artifacts'
    agent: orchestrator
    skill: artifact-publisher
    condition: "validation_status == 'pass'"
    inputs:
      - artifact-registry.json
    policy: auto-on-pass
    retry:
      max_attempts: 3
      on_failure: log_and_continue

completion_criteria:
  - Primary agent failure detected and categorized
  - Fallback agent selected appropriately
  - All artifacts preserved during fallback
  - Error details passed to fallback agent
  - Fallback agent received correct context
  - Required tools/context available for fallback agent
  - Task completed successfully by fallback agent
  - Plan updated with fallback assignment
  - Fallback reason documented in reasoning files

test_scenarios:
  explicit_fallback:
    description: 'Test explicit fallback agent from agent definition'
    primary_agent: architect
    expected_fallback: developer
    failure_type: non_recoverable

  capability_matrix:
    description: 'Test capability matrix fallback when no explicit fallback'
    primary_agent: pm
    expected_fallback: analyst
    failure_type: timeout

  context_preservation:
    description: 'Test context preservation during fallback'
    primary_agent: architect
    expected_fallback: developer
    failure_type: non_recoverable
    validate_artifacts: true

  fallback_chain:
    description: 'Test multi-level fallback chain'
    primary_agent: developer
    expected_fallback_chain: [refactoring-specialist, code-reviewer]
    failure_type: invalid_output

  invalid_output:
    description: 'Test fallback after max retries on invalid output'
    primary_agent: developer
    expected_fallback: refactoring-specialist
    failure_type: invalid_output
    max_retries: 3
