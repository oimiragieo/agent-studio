# Security Validation Hook (PreToolUse)
# First line of defense - validates all tool usage before execution

---
name: security-validation
description: "Enterprise security validation for all tool invocations"
trigger: PreToolUse
priority: highest  # Execute before all other hooks

# ==============================================================================
# Hook Configuration
# ==============================================================================

config:
  enabled: true
  fail_on_error: true  # Block execution if validation fails
  log_all_attempts: true
  log_location: ".claude/context/audit/security-validation.log"

# ==============================================================================
# Validation Steps
# ==============================================================================

steps:
  # Step 1: Load security policies
  - action: load_policies
    description: "Load permission modes, tool permissions, and security policies"
    files:
      - ".claude/system/permissions/permission-modes.yaml"
      - ".claude/system/permissions/tool-permissions.yaml"
      - ".claude/system/permissions/security-policies.yaml"

  # Step 2: Check permission mode
  - action: check_permission_mode
    description: "Validate against current permission mode"
    logic: |
      current_mode = get_permission_mode()  # default, acceptEdits, bypassPermissions, plan

      if current_mode == "plan":
        # Plan mode: block all execution
        return {"behavior": "deny", "message": "Plan mode: No execution allowed"}

      if current_mode == "bypassPermissions":
        # Bypass mode: allow but log (HIGH RISK)
        log_warning("SECURITY: bypassPermissions mode active - no validation applied")
        return {"behavior": "allow"}

      # Continue to detailed validation for other modes
      return {"behavior": "continue"}

  # Step 3: Agent tool permission check
  - action: check_agent_permissions
    description: "Verify agent has permission to use this tool"
    logic: |
      agent = get_current_agent()
      tool = tool_name
      agent_permissions = load_agent_permissions(agent)

      if tool in agent_permissions["restricted_tools"]:
        return {"behavior": "deny", "message": f"{agent} is not authorized to use {tool}"}

      if tool not in agent_permissions["allowed_tools"]:
        return {"behavior": "deny", "message": f"{tool} not in {agent}'s allowed tools list"}

      return {"behavior": "continue"}

  # Step 4: Bash command security validation
  - action: validate_bash_command
    condition: tool_name == "Bash"
    description: "Security validation for Bash commands"
    logic: |
      command = tool_input["command"]

      # Load blocked patterns
      blocked_patterns = load_bash_security_policies()["critical_blocks"]

      for block in blocked_patterns:
        if regex_match(block["pattern"], command):
          log_security_violation(
            severity=block["severity"],
            reason=block["reason"],
            command=command
          )
          if block["alert"]:
            send_security_alert(f"CRITICAL: Blocked dangerous command: {command}")

          return {"behavior": "deny", "message": f"ðŸ›‘ Blocked: {block['reason']}"}

      # Check high-risk patterns requiring approval
      high_risk_patterns = load_bash_security_policies()["high_risk_commands"]

      for risk in high_risk_patterns:
        if regex_match(risk["pattern"], command):
          if risk["require_approval"]:
            approval = request_user_approval(risk["approval_message"] or f"Execute: {command}?")
            if not approval:
              return {"behavior": "deny", "message": "User denied approval"}

      # Timeout validation
      timeout = tool_input.get("timeout", 120000)
      if timeout > 600000:  # Max 10 minutes
        return {"behavior": "deny", "message": "Timeout exceeds maximum (600000ms)"}

      return {"behavior": "allow"}

  # Step 5: File operation security validation
  - action: validate_file_operations
    condition: tool_name in ["Write", "Edit", "NotebookEdit"]
    description: "Security validation for file operations"
    logic: |
      file_path = tool_input["file_path"]

      # Path validation (directory traversal prevention)
      if contains_traversal(file_path):
        return {"behavior": "deny", "message": "âš ï¸  Path traversal attack detected"}

      # Blocked directories
      blocked_dirs = ["/etc/**", "/sys/**", "/dev/**", "~/.ssh/**", "~/.aws/**"]
      if matches_any_pattern(file_path, blocked_dirs):
        return {"behavior": "deny", "message": f"âš ï¸  Access to {file_path} is blocked"}

      # Sensitive files
      sensitive_patterns = [r"\.env(\..*)?$", r"secrets/.*", r".*\.key$", r".*\.pem$"]
      if matches_any_pattern(file_path, sensitive_patterns):
        return {"behavior": "deny", "message": "âš ï¸  Cannot modify sensitive files"}

      # Files requiring approval
      approval_patterns = ["package.json$", "Dockerfile$", ".github/workflows/"]
      if matches_any_pattern(file_path, approval_patterns):
        approval = request_user_approval(f"Modify {file_path}?")
        if not approval:
          return {"behavior": "deny", "message": "User denied approval"}

      # Scan for secrets (Write/Edit only)
      if tool_name in ["Write", "Edit"]:
        content = tool_input.get("new_string") or tool_input.get("content")
        if content:
          secrets = scan_for_secrets(content)
          if secrets:
            return {"behavior": "deny", "message": f"âš ï¸  Secrets detected: {', '.join(secrets)}"}

      return {"behavior": "allow"}

  # Step 6: PII detection
  - action: scan_for_pii
    condition: tool_name in ["Write", "Edit", "Bash"]
    description: "Detect and redact PII in outputs"
    logic: |
      # Get content to scan
      content = get_tool_input_content()

      # Scan for PII patterns
      pii_detected = []
      pii_patterns = {
        "email": r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}",
        "ssn": r"\b\d{3}-\d{2}-\d{4}\b",
        "credit_card": r"\b(?:\d{4}[- ]?){3}\d{4}\b",
        "phone": r"\b\d{3}[-.]?\d{3}[-.]?\d{4}\b"
      }

      for pii_type, pattern in pii_patterns.items():
        if regex_match(pattern, content):
          pii_detected.append(pii_type)

      if pii_detected:
        log_security_event(
          event="pii_detected",
          types=pii_detected,
          tool=tool_name
        )
        approval = request_user_approval(
          f"âš ï¸  PII detected ({', '.join(pii_detected)}). Proceed with caution?"
        )
        if not approval:
          return {"behavior": "deny", "message": "PII detection: User cancelled"}

      return {"behavior": "allow"}

  # Step 7: Web access validation
  - action: validate_web_access
    condition: tool_name in ["WebFetch", "WebSearch"]
    description: "Validate web access against security policies"
    logic: |
      if tool_name == "WebFetch":
        url = tool_input["url"]

        # Domain validation
        if is_blocked_domain(url):
          return {"behavior": "deny", "message": "âš ï¸  Domain is blocked"}

        if not is_allowed_domain(url):
          return {"behavior": "deny", "message": "âš ï¸  Domain not in allowlist"}

        # Rate limiting
        if exceeds_rate_limit("web_fetch"):
          return {"behavior": "deny", "message": "âš ï¸  Rate limit exceeded"}

      return {"behavior": "allow"}

  # Step 8: MCP tool validation
  - action: validate_mcp_tools
    condition: tool_name.startswith("mcp__")
    description: "Validate MCP server and tool authorization"
    logic: |
      # Parse MCP tool name: mcp__server__tool
      parts = tool_name.split("__")
      if len(parts) != 3:
        return {"behavior": "deny", "message": "Invalid MCP tool name format"}

      server_name = parts[1]
      tool_name_only = parts[2]

      # Check server allowlist
      allowed_servers = get_allowed_mcp_servers()
      if server_name not in allowed_servers:
        return {"behavior": "deny", "message": f"MCP server '{server_name}' not authorized"}

      # Check tool allowlist for this server
      server_config = allowed_servers[server_name]
      if server_config["tools"] != "*" and tool_name_only not in server_config["tools"]:
        return {"behavior": "deny", "message": f"Tool '{tool_name_only}' not authorized for server '{server_name}'"}

      return {"behavior": "allow"}

# ==============================================================================
# Audit Logging
# ==============================================================================

audit:
  enabled: true
  log_format: json
  log_fields:
    - timestamp
    - agent
    - tool
    - action
    - result  # allow/deny
    - reason
    - user
    - session_id
  export_to:
    - file: ".claude/context/audit/security-validation.log"
    - siem: false  # Set to true for SIEM integration

# ==============================================================================
# Alert Configuration
# ==============================================================================

alerts:
  enabled: true
  channels:
    - type: log
      level: warn
      condition: "result == 'deny'"

    - type: slack
      enabled: false  # Set webhook_url for production
      webhook_url: null
      condition: "severity == 'critical'"

    - type: email
      enabled: false  # Set SMTP config for production
      condition: "violations_per_hour > 5"

# ==============================================================================
# Helper Functions
# ==============================================================================

helpers:
  contains_traversal:
    description: "Check if path contains traversal patterns"
    implementation: |
      return any(pattern in path for pattern in ["../", "..\\", "%2e%2e%2f"])

  scan_for_secrets:
    description: "Scan content for hardcoded secrets"
    patterns:
      - name: "AWS Access Key"
        regex: "AKIA[0-9A-Z]{16}"
      - name: "GitHub Token"
        regex: "ghp_[0-9a-zA-Z]{36}"
      - name: "Anthropic API Key"
        regex: "sk-ant-[0-9a-zA-Z-]+"
      - name: "Private Key"
        regex: "-----BEGIN (RSA |EC |OPENSSH )?PRIVATE KEY-----"

  is_blocked_domain:
    description: "Check if domain is in blocklist"
    blocklist:
      - "*.onion"
      - "localhost"
      - "127.0.0.1"
      - "192.168.*"
      - "10.*"

  is_allowed_domain:
    description: "Check if domain is in allowlist"
    allowlist:
      - "*.anthropic.com"
      - "*.github.com"
      - "*.npmjs.com"
      - "*.stackoverflow.com"
      - "docs.*.com"
